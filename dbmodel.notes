
1. add a row to the Splits table
2. add all the rows to Dishes and People. These can be done in parallel. SOMEHOW get back an array of their primary keys.
3. Construct and add the entries for Orders.
Say we have arrays people, peopleIDs, dishes, dishesIDs and orders, we'd have something like

var json = JSON.parse('{"people":["Mark","Damian","Kai","Kapil"],"dishes":[{"name":"Pitcher","price":19.4},{"name":"Wings","price":15.75},{"name":"Scotch Egg","price":14.6},{"name":"Pizza","price":22.1},{"name":"Shrimp","price":12.98}],"orders":[[true,true,true,true],[false,false,true,true],[true,true,false,false],[true,true,true,true],[false,false,true,false]],"tax":7.65,"tip":20}')

var peopleIDs = json.people.map(e => e.substring(0,3) + 'ID');
var dishesIDs = json.dishes.map(e => e.name.substring(0,3) + 'ID');

for (let r in json.orders) {
  for (let c in json.orders[r]) {
    console.log(r, c, dishesIDs[r], peopleIDs[c], json.orders[r][c]);
  }
}


json.orders.map((row, ri) => (row.map((col, ci) => ({orderIndex: ri, personIndex: ci, val: col}))))
  .reduce((a,b) => a.concat(b))
  .filter(el => el.val)
  .map(el => `(${dishesIDs[el.orderIndex]}, ${peopleIDs[el.personIndex]})`)
  .reduce((a,b) => a + ', ' + b);

// without final reduce
[
  "(PitID, MarID)",
  "(PitID, DamID)",
  "(PitID, KaiID)",
  "(PitID, KapID)",
  "(WinID, KaiID)",
  "(WinID, KapID)",
  "(ScoID, MarID)",
  "(ScoID, DamID)",
  "(PizID, MarID)",
  "(PizID, DamID)",
  "(PizID, KaiID)",
  "(PizID, KapID)",
  "(ShrID, KaiID)"
]

// with final reduce 
"(PitID, MarID), (PitID, DamID), (PitID, KaiID), (PitID, KapID), (WinID, KaiID), (WinID, KapID), (ScoID, MarID), (ScoID, DamID), (PizID, MarID), (PizID, DamID), (PizID, KaiID), (PizID, KapID), (ShrID, KaiID)"


CREATE TABLE Splits (
  split_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  tax float,
  tip_percent float,
  link_id varchar(6),
  created timestamp with time zone,
  last_accessed timestamp with time zone
);
INSERT INTO Splits (tax, tip_percent, link_id, created, last_accessed) 
VALUES 
  (5.10, 15.5, 'abcdef', now(), now()),
  (10.00, 16.0, 'ghijkl', now(), now());

CREATE TABLE Dishes (
  dish_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name varchar(20),
  price float,
  position INT,
  split_id INT REFERENCES Splits
);

/* position is 0 based */
INSERT INTO Dishes (name, price, position, split_id) 
VALUES 
  ('Pitcher', 19.40, 0, 1),
    ('Wings', 15.75, 1, 1),
    ('Scotch Egg', 14.60, 2, 1),
    ('Pizza', 22.10, 3, 1),
    ('Shrimp', 12.98, 4, 1);

CREATE TABLE People (
  person_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name VARCHAR(20),
  position INT,
  split_id INT REFERENCES Splits 
);

/* position is 0 based */
INSERT INTO People (name, position, split_id) 
VALUES 
  ('Mark', 0, 1),
  ('Damian', 1, 1),
    ('Kai', 2, 1),
    ('Kapil', 3, 1);

CREATE TABLE Orders (
  order_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  dish_id INT REFERENCES Dishes,
  person_id INT REFERENCES People
);

/* Inserting like this would only work if we also had the split_id*/
INSERT INTO Orders (dish_id, person_id) 
SELECT d.dish_id, p.person_id
FROM People p
  CROSS JOIN Dishes d
WHERE
  d.name = 'Pitcher' AND (p.name in ('Mark', 'Damian', 'Kai', 'Kapil'))
    OR d.name = 'Wings' AND (p.name in ('Kai', 'Kapil')) 
    OR d.name = 'Scotch Egg' AND (p.name in ('Mark', 'Damian'))
    OR d.name = 'Pizza' AND (p.name in ('Mark', 'Damian', 'Kai', 'Kapil'))
    OR d.name = 'Shrimp' AND (p.name in ('Kai'));

