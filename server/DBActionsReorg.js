/* eslint-disable camelcase */
/* eslint-disable no-plusplus */
/* eslint-disable no-await-in-loop */

const randomstring = require('randomstring');

const Database = require('./DatabaseConnection');

const createSplitsTable =
  `CREATE TABLE IF NOT EXISTS Splits (
    split_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    tax FLOAT,
    tip_percent FLOAT,
    link_code VARCHAR(6),
    created TIMESTAMP WITH TIME ZONE,
    last_accessed TIMESTAMP WITH TIME ZONE
  );`;

const createDishesTable =
  `CREATE TABLE IF NOT EXISTS Dishes (
    dish_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(20),
    price FLOAT,
    position INT,
    split_id INT REFERENCES Splits
  );`;

const createPeopleTable =
  `CREATE TABLE IF NOT EXISTS People (
    person_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(20),
    position INT,
    split_id INT REFERENCES Splits 
  );`;

const createOrderTable =
  `CREATE TABLE IF NOT EXISTS Orders (
    order_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    dish_id INT REFERENCES Dishes,
    person_id INT REFERENCES People
  );`;

const Status = {
  UNINITIALIZED: 'uninitialized',
  INITIALIZING: 'initializing',
  READY: 'ready'
};

// get a rowNum x colNum array of false's
function getFalseBooleanArray(rowNum, colNum) {
  return [ ...Array(rowNum).keys() ].map(() => new Array(colNum).fill(false));
}

class DBActionsReorg {
  // TODO how do we make sure this query happens before any future ones?
  constructor() {
    this.db = new Database();
    this.status = Status.UNINITIALIZED;
  }

  // Function to make tables if they're not already made.
  // Only gets called once.
  async _initialize() {
    this.status = Status.INITIALIZING;

    await this.db.queryAsync(createSplitsTable);
    await this.db.queryAsync(createDishesTable);
    await this.db.queryAsync(createPeopleTable);
    await this.db.queryAsync(createOrderTable);

    this.status = Status.READY;
    console.log(`status: ${this.status}`);
  }

  // Calls _initialize() if it hasn't already been returns a
  // promise that gets resolved when the database tables are ready.
  _checkReady() {
    console.log(`Call to _checkReady. Current status: ${this.status}`);
    if (this.status === Status.UNINITIALIZED) {
      this.waiting = this._initialize();
    }
    return this.waiting;
  }

  // get a 6char random link code that isn't in the db yet
  getUnusedLinkCodePromise() {
    return this._checkReady().then(async () => {
      let tries = 5;
      while (tries-- > 0) {
        let candidate = randomstring.generate(6);

        const res = await this.db.queryAsync(
          'SELECT * FROM Splits WHERE link_code = $1 LIMIT 1;',
          [ candidate ]
        );

        if (res.rowCount === 0) {
          return Promise.resolve(candidate);
        }
        console.log(`${candidate} failed, trying again...`);
      }
      throw new Error('Ran out of tries to get unusedLinkCode');
    });
  }

  assembleObjFromLinkCodePromise(link_code) {
    // 1. look up the link_code in the Splits table,
    return this._checkReady().then(async () => {
      const res1 = await this.db.queryAsync(
        'SELECT * FROM Splits WHERE link_code = $1',
        [ link_code ]
      );

      // not found!
      if (res1.rowCount === 0) {
        throw new Error(`${link_code} not found!`);
      }
      const { split_id } = res1.rows[0];
      const resurectedObj = {
        people: [],
        dishes: [],
        orders: [],
        tax: res1.rows[0].tax,
        tip: res1.rows[0].tip_percent
      };

      // 2. look up the splitID as the FK in the Dishes table, order by position
      const res2 = await this.db.queryAsync(
        'SELECT * FROM Dishes WHERE split_id = $1 ORDER BY position',
        [ split_id ]
      );

      const dish_ids = [];
      res2.rows.forEach((row) => {
        resurectedObj.dishes.push({
          name: row.name,
          price: row.price
        });
        dish_ids.push(row.dish_id);
      });

      // 2a. look up the splitID as the FK in the People table, order by position
      const res3 = await this.db.queryAsync(
        'SELECT * FROM People WHERE split_id = $1 ORDER BY position',
        [ split_id ]
      );

      const person_ids = [];
      res3.rows.forEach((row) => {
        resurectedObj.people.push(row.name);
        person_ids.push(row.person_id);
      });

      // 3. look up the order_ids as the FK in the Orders table
      const res4 = await this.db.queryAsync(
        `SELECT * FROM Orders WHERE dish_id 
          IN (SELECT value::TEXT::INT FROM json_array_elements($1))`,
        [ JSON.stringify(dish_ids) ]
      );

      resurectedObj.orders = getFalseBooleanArray(
        dish_ids.length,
        person_ids.length
      );

      res4.rows.forEach((row) => {
        const dishIndex = dish_ids.indexOf(row.dish_id);
        const personIndex = person_ids.indexOf(row.person_id);
        resurectedObj.orders[dishIndex][personIndex] = true;
      });

      return Promise.resolve(resurectedObj);
    });
  }

  // TODO it'd be nice if we didn't thave to redefine the types of each column
  // in the AS statement
  // WHY you don't need VALUES if you're inserting a subquery

  // https://www.postgresql.org/docs/9.4/static/functions-json.html
  // https://stackoverflow.com/questions/9692319/how-can-i-insert-values-into-a-table-using-a-subquery-with-more-than-one-result
  makeNewSplitPromise(splitObj) {
    let link_code;
    return this._checkReady()
      .then(() => this.getUnusedLinkCodePromise())
      .then(unusedLinkCode => {
        console.log('unusedLinkCode is: ', unusedLinkCode);
        link_code = unusedLinkCode;

        // 1. add a row to the Splits table
        return this.db.queryAsync(
          `INSERT INTO Splits (tax, tip_percent, link_code, created) 
            VALUES ($1, $2, $3, now()) RETURNING split_id`,
          [ splitObj.tax, splitObj.tip, unusedLinkCode ]
        );
      })
      .then(async (res1) => {
        const { split_id } = res1.rows[0];

        // 2a. Add all the rows to Dishes, get back an array of their primary keys.
        const dishesRowsToInsert = DBActionsReorg.makeDishRows(splitObj.dishes, split_id);
        const dishIDs = (await this.db.queryAsync(
          `INSERT INTO Dishes (name, price, position, split_id)  
             (SELECT * FROM json_to_recordset($1) 
                AS x(name varchar(20), price FLOAT, position INT, split_id INT))
           RETURNING dish_id`,
          [ JSON.stringify(dishesRowsToInsert) ]
        )).rows.map(r => r.dish_id);

        // 2b. Add all the rows to People, get back an array of their primary keys.
        const peopleRowsToInsert = DBActionsReorg.makePeopleRows(splitObj.people, split_id);
        const peopleIDs = (await this.db.queryAsync(
          `INSERT INTO People (name, position, split_id)  
             (SELECT * FROM json_to_recordset($1) 
                AS x(name varchar(20), position INT, split_id INT))
           RETURNING person_id`,
          [ JSON.stringify(peopleRowsToInsert) ]
        )).rows.map(r => r.person_id);

        // 3. Construct and add the entries for Orders.
        const orderRowsToInsert = DBActionsReorg.makeOrderRows(splitObj.orders, dishIDs, peopleIDs);
        return this.db.queryAsync(
          `INSERT INTO Orders (dish_id, person_id)  
             (SELECT * FROM json_to_recordset($1) 
                AS x(dish_id INT, person_id INT))`,
          [ JSON.stringify(orderRowsToInsert) ]
        );
      })
      .then(() => Promise.resolve(link_code));
  }

  static makeDishRows(dishes, split_id) {
    return dishes.map((d, i) => ({
      name: d.name,
      price: d.price,
      position: i,
      split_id: split_id
    }));
  }

  static makePeopleRows(people, split_id) {
    return people.map((name, i) => ({
      name: name,
      position: i,
      split_id: split_id
    }));
  }

  static makeOrderRows(orders, dishIDs, peopleIDs) {
    return orders.map((row, ri) => (row.map((col, ci) => ({
      orderIndex: ri,
      personIndex: ci,
      val: col
    }))))
      .reduce((a, b) => a.concat(b))
      .filter(el => el.val)
      .map(el => ({
        dish_id: dishIDs[el.orderIndex],
        person_id: peopleIDs[el.personIndex]
      }));
  }
}

async function serializeAndDesearializeTest() {
  const splitObj = JSON.parse(`{
    "people":["Mark","Damian","Kai","Kapil"],
    "dishes":[
      {"name":"Pitcher","price":19.4},{"name":"Wings","price":15.75},
      {"name":"Scotch Egg","price":14.6},{"name":"Pizza","price":22.1},
      {"name":"Shrimp","price":12.98}],
    "orders":[
      [true,true,true,true],[false,false,true,true],[true,true,false,false],
      [true,true,true,true],[false,false,true,false]],
    "tax":7.65,
    "tip":200}`);

  const dbActions = new DBActionsReorg();

  // dbActions.makeNewSplitPromise(splitObj).then((link_code) => {
  //   dbActions.assembleObjFromLinkCodePromise(link_code).then((newObj) => {
  //     printOutOrigAndResurrectedObjects(splitObj, newObj);
  //   });
  // });

  const link_code = await dbActions.makeNewSplitPromise(splitObj);
  const newObj = await dbActions.assembleObjFromLinkCodePromise(link_code);
  printOutOrigAndResurrectedObjects(splitObj, newObj);
}

// Print out both JSON objects next to each other, indicating any differences.
// Will print empty object if undefined, 'null' if null.
function printOutOrigAndResurrectedObjects(obj1 = {}, obj2 = {}) {
  function getAndPad(arr, i) {
    const returnMe = (i < arr.length) ? arr[i] : 'NOT FOUND';
    return returnMe.padEnd(30);
  }

  const obj1Arr = JSON.stringify(obj1, null, 2).split('\n');
  const obj2Arr = JSON.stringify(obj2, null, 2).split('\n');
  let objectsEqual = true;
  let i = 0;
  while (i < Math.max(obj1Arr.length, obj2Arr.length)) {
    const left = getAndPad(obj1Arr, i);
    const right = getAndPad(obj2Arr, i);
    const same = left === right;
    objectsEqual = objectsEqual && same;
    // console.log(`${same ? ' ' : 'X'} | ${left} | ${right}`);
    i += 1;
  }
  console.log(`Objects are${objectsEqual ? '' : ' NOT'} the same.`);
}

serializeAndDesearializeTest();


// module.exports = DBActionsReorg;

