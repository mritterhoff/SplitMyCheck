/* eslint-disable camelcase */
/* eslint-disable no-plusplus */
/* eslint-disable no-await-in-loop */
/* eslint-disable prefer-destructuring */

// 6 alphanumeric chars = (10+26+26)^6 = 62^6 = 56.8 billion combinations
// at 280,610 entries, there'll be a 50% of a collision
// https://www.wolframalpha.com/input/?i=solve+1-e%5E(-n%5E2%2F(2d))%3D.5,++d+%3D+(10%2B26%2B26)%5E6+over+the+reals
// "solve 1-e^(-n^2/(2d))=.5, d = (10+26+26)^6 over the reals"
const randomstring = require('randomstring');

const Database = require('./DatabaseConnection');

const createSplitsTable =
  `CREATE TABLE IF NOT EXISTS Splits (
    split_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    tax FLOAT,
    tip_percent FLOAT,
    link_code VARCHAR(6),
    created TIMESTAMP WITH TIME ZONE,
    last_accessed TIMESTAMP WITH TIME ZONE
  );`;

const createDishesTable =
  `CREATE TABLE IF NOT EXISTS Dishes (
    dish_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(40),
    price FLOAT,
    position INT,
    split_id INT REFERENCES Splits
  );`;

const createPeopleTable =
  `CREATE TABLE IF NOT EXISTS People (
    person_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(40),
    position INT,
    split_id INT REFERENCES Splits 
  );`;

const createOrderTable =
  `CREATE TABLE IF NOT EXISTS Orders (
    order_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    dish_id INT REFERENCES Dishes,
    person_id INT REFERENCES People
  );`;

const Status = {
  UNINITIALIZED: 'uninitialized',
  INITIALIZING: 'initializing',
  READY: 'ready'
};

// get a rowNum x colNum array of false's
function getFalseBooleanArray(rowNum, colNum) {
  return [ ...Array(rowNum).keys() ].map(() => new Array(colNum).fill(false));
}

class DBActionsReorg {
  constructor() {
    this.db = new Database();
    this.status = Status.UNINITIALIZED;
    this._onReadyPromise = undefined;
  }

  // Function to make tables if they're not already made. Gets called exactly once.
  async _initialize() {
    this.status = Status.INITIALIZING;

    try {
      await this.db.queryAsync(createSplitsTable);
      await this.db.queryAsync(createDishesTable);
      await this.db.queryAsync(createPeopleTable);
      await this.db.queryAsync(createOrderTable);
    }
    catch (e) {
      throw new Error('Issue setting up tables:', e);
    }

    this.status = Status.READY;
    console.log(`status: ${this.status}`);
  }

  // Calls _initialize() if it hasn't already been returns a
  // promise that gets resolved when the database tables are ready.
  _checkReady() {
    // console.log(`Call to _checkReady. Current status: ${this.status}`);
    if (this.status === Status.UNINITIALIZED) {
      this._onReadyPromise = this._initialize();
    }
    return this._onReadyPromise;
  }

  // get a 6char random link code that isn't in the db yet
  getUnusedLinkCodePromise() {
    return this._checkReady().then(async () => {
      let tries = 3;
      while (tries-- > 0) {
        const candidate = randomstring.generate(6);

        const res = await this.db.queryAsync(
          'SELECT * FROM Splits WHERE link_code = $1 LIMIT 1;',
          [ candidate ]
        );

        if (res.rowCount === 0) {
          return Promise.resolve(candidate);
        }
        console.log(`${candidate} failed, trying again...`);
      }
      throw new Error('Ran out of tries to get unusedLinkCode');
    });
  }

  assembleObjFromLinkCodePromise(link_code) {
    let split_id;
    const dish_ids = [];
    const person_ids = [];
    const resurectedObj = {
      people: [],
      dishes: [],
      orders: []
    };

    // 1. look up the link_code in the Splits table,
    return this._checkReady().then(() =>
      this.db.queryAsync(
        'SELECT * FROM Splits WHERE link_code = $1',
        [ link_code ]
      ))
      .then((res1) => {
        if (res1.rowCount === 0) {
          throw new Error(`${link_code} not found!`);
        }
        split_id = res1.rows[0].split_id;
        resurectedObj.tax = res1.rows[0].tax;
        resurectedObj.tip = res1.rows[0].tip_percent;

        // 2. look up the splitID as the FK in the Dishes table, order by position
        return this.db.queryAsync(
          'SELECT * FROM Dishes WHERE split_id = $1 ORDER BY position',
          [ split_id ]
        );
      })
      .then((res2) => {
        res2.rows.forEach((row) => {
          resurectedObj.dishes.push({
            name: row.name,
            price: row.price
          });
          dish_ids.push(row.dish_id);
        });

        // 2a. look up the splitID as the FK in the People table, order by position
        return this.db.queryAsync(
          'SELECT * FROM People WHERE split_id = $1 ORDER BY position',
          [ split_id ]
        );
      })
      .then((res3) => {
        res3.rows.forEach((row) => {
          resurectedObj.people.push(row.name);
          person_ids.push(row.person_id);
        });

        // 3. look up the order_ids as the FK in the Orders table
        return this.db.queryAsync(
          `SELECT * FROM Orders WHERE dish_id 
          IN (SELECT value::TEXT::INT FROM json_array_elements($1))`,
          [ JSON.stringify(dish_ids) ]
        );
      })
      .then((res4) => {
        resurectedObj.orders = getFalseBooleanArray(
          dish_ids.length,
          person_ids.length
        );

        res4.rows.forEach((row) => {
          const dishIndex = dish_ids.indexOf(row.dish_id);
          const personIndex = person_ids.indexOf(row.person_id);
          resurectedObj.orders[dishIndex][personIndex] = true;
        });

        return Promise.resolve(resurectedObj);
      });
  }

  // TODO it'd be nice if we didn't thave to redefine the types of each column
  // in the AS statement
  // WHY you don't need VALUES if you're inserting a subquery

  // https://www.postgresql.org/docs/9.4/static/functions-json.html
  // https://stackoverflow.com/questions/9692319/how-can-i-insert-values-into-a-table-using-a-subquery-with-more-than-one-result
  makeNewSplitPromise(splitObj) {
    let link_code;
    return this._checkReady()
      .then(() => this.getUnusedLinkCodePromise())
      .then((unusedLinkCode) => {
        console.log('unusedLinkCode is: ', unusedLinkCode);
        link_code = unusedLinkCode;

        // 1. add a row to the Splits table
        return this.db.queryAsync(
          `INSERT INTO Splits (tax, tip_percent, link_code, created) 
            VALUES ($1, $2, $3, now()) RETURNING split_id`,
          [ splitObj.tax, splitObj.tip, unusedLinkCode ]
        );
      })
      .then(async (res1) => {
        const { split_id } = res1.rows[0];
        const promises = [];

        // 2a. Add all the rows to Dishes, get back an array of their primary keys.
        promises.push(this.db.queryAsync(
          `INSERT INTO Dishes (name, price, position, split_id)  
             (SELECT * FROM json_to_recordset($1) 
                AS x(name varchar(40), price FLOAT, position INT, split_id INT))
           RETURNING dish_id`,
          [ makeDishRows(splitObj.dishes, split_id) ]
        ));
        // 2b. Add all the rows to People, get back an array of their primary keys.
        promises.push(this.db.queryAsync(
          `INSERT INTO People (name, position, split_id)  
             (SELECT * FROM json_to_recordset($1) 
                AS x(name varchar(40), position INT, split_id INT))
           RETURNING person_id`,
          [ makePeopleRows(splitObj.people, split_id) ]
        ));

        return Promise.all(promises);
      })
      .then((res) => {
        const dishIDs = res[0].rows.map(r => r.dish_id);
        const peopleIDs = res[1].rows.map(r => r.person_id);

        // 3. Construct and add the entries for Orders.
        return this.db.queryAsync(
          `INSERT INTO Orders (dish_id, person_id)  
             (SELECT * FROM json_to_recordset($1) 
                AS x(dish_id INT, person_id INT))`,
          [ makeOrderRows(splitObj.orders, dishIDs, peopleIDs) ]
        );
      })
      .then(() => Promise.resolve(link_code));
  }
}

function makeDishRows(dishes, split_id) {
  return JSON.stringify(dishes.map((d, i) => ({
    name: d.name,
    price: d.price,
    position: i,
    split_id: split_id
  })));
}

function makePeopleRows(people, split_id) {
  return JSON.stringify(people.map((name, i) => ({
    name: name,
    position: i,
    split_id: split_id
  })));
}

function makeOrderRows(orders, dishIDs, peopleIDs) {
  return JSON.stringify(orders.map((row, ri) => (row.map((col, ci) => ({
    orderIndex: ri,
    personIndex: ci,
    val: col
  }))))
    .reduce((a, b) => a.concat(b))
    .filter(el => el.val)
    .map(el => ({
      dish_id: dishIDs[el.orderIndex],
      person_id: peopleIDs[el.personIndex]
    })));
}

module.exports = DBActionsReorg;
